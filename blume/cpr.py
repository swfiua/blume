"""
**A new paradigm for the universe.**

https://msp.warwick.ac.uk/~cpr/paradigm

ISBN: 9781973129868

I keep dipping into this book.

Each time with new understanding.  Each time with a new perspective.

It is a wonderful work, with compelling arguments.

Chapter 2, Sciama's principle finishes with:

   Sciama's initiative, to base a dynamical theory on Mach's principle as
   formulated i Sciama's principle, has never been followed up and this
   approach to dynamics remains dormant.  One of the aims of this book is to
   reawaken this approach.

One of the aims of `blume` is to help understanding of such theories.

In particular, help my own understanding with computer simulations.

This module will explore some of the mathematics of the book.

It will require `astropy`.  

Solar system, galactic and local galaxy visualsation and simulation.

Simulation of gravitational waves generated by black hole mergers using the
physics of *the book*.

Simulations of gravitational wave from a new galactic arrival.
"""

import argparse

import random

import math

import curio

import astropy.units as u
import astropy.coordinates as coord

from . import magic
from . import farm as fm

from matplotlib import pyplot as plt
import numpy as np

async def run(**args):

    farm = fm.Farm()

    spiral = Spiral()

    farm.add_node(spiral, background=True)
    farm.add_edge(farm.carpet, spiral)

    await farm.start()
    print('about to run farm')
    await farm.run()


def main(args=None):

    parser = argparse.ArgumentParser()
    args = parser.parse_args(args)

    curio.run(run(**args.__dict__), with_monitor=True)


class Spiral(magic.Ball):

    def __init__(self):

        super().__init__()

        self.A = 0.0005
        self.B = 0.0000015

        self.Mcent = 0.03
        self.Mball = 0.
        self.Mdisc = 0.

        self.K = self.Mcent
        self.EE = -0.00000345
        self.CC = -10

        self.rmin = 5000
        self.rmax = 50000

    def v(self, r):
        """ Velocity at radius r """
        A = self.A
        K = self.K
        CC = self.CC

        return (2 * A) - (2 * (K * A * math.log(1 + K) / r)) + CC / r


    def vinert(self, r, v):

        return v - (self.A * r) / (self.K + r)

    def rdoubledot(self, r, vinert):

        rdd = ((vinert ** 2) / r) - (self.Mcent/(r**2))
        rdd -= self.Mdisc/(self.rmax ** 2)
        rdd -= self.Mball * r /(self.rmax ** 3)

        return rdd

    async def run(self):

        plt.cla()
        ax = plt.subplot(111)

        rr = np.linspace(self.rmin, self.rmax, 1000)
        #vv = [self.v(r) for r in rr]
        vv = self.v(rr)
        ii = self.vinert(rr, vv)
        rdd = self.rdoubledot(rr, ii)
        #ii = [self.vinert(r, v) for (r, v) in zip(rr, vv)]
        #rdd = [self.rdoubledot(r, v) for (r, v) in zip(rr, ii)]
        ax.plot(rr, vv)
        ax.plot(rr, ii)
        ax.plot(rr, rdd)
        
        plt.xlabel('r', color='r')
        plt.ylabel('velocity', color='y')
        plt.legend(loc=0)
          
        print('spiral')

        await self.put(magic.fig2data(plt))

if __name__ == '__main__':
 
    
    main()
