"""
**A new paradigm for the universe.**

https://msp.warwick.ac.uk/~cpr/paradigm

ISBN: 9781973129868

I keep dipping into this book.

Each time with new understanding.  Each time with a new perspective.

It is a wonderful work, with compelling arguments.

Chapter 2, Sciama's principle finishes with:

   Sciama's initiative, to base a dynamical theory on Mach's principle as
   formulated i Sciama's principle, has never been followed up and this
   approach to dynamics remains dormant.  One of the aims of this book is to
   reawaken this approach.

One of the aims of `blume` is to help understanding of such theories.

In particular, help my own understanding with computer simulations.

This module will explore some of the mathematics of the book.

It will require `astropy`.  

Solar system, galactic and local galaxy visualsation and simulation.

Simulation of gravitational waves generated by black hole mergers using the
physics of *the book*.

Simulations of gravitational wave from a new galactic arrival.
"""

import argparse

import random


import curio

import astropy.units as u
import astropy.coordinates as coord

from . import magic
from . import farm as fm

from matplotlib import pyplot as plt

async def run(**args):

    farm = magic.GeeFarm()

    spiral = Spiral()

    farm.add_node(spiral)
    farm.add_node(fm.GuidoClock())

    await farm.start()
    await farm.run()


def main(args=None):

    parser = argparse.ArgumentParser()
    args = parser.parse_args(args)

    curio.run(run(**args.__dict__))


class Spiral(magic.Ball):

    def __init__(self):

        super().__init__()

        self.A = 0.0005
        self.B = 0.0000015

        self.Mcent = 0.03
        self.Mball = 0.
        self.Mdisc = 0.

        self.K = self.Mcent
        self.EE = -0.00000345
        self.CC = -10

    def v(self, r):
        """ Velocity at radius r """
        A = self.A
        K = self.K
        CC = self.CC

        return (2 * A) -2(K * A * math.log(1 + K) / r) + CC / r

    async def run(self):

        ax = plt.subplot(111)

        rr = list(range(1000))
        vv = [self.v(r) for r in rr]
        ax.plot(rr, vv)

        self.put(plt)

if __name__ == '__main__':
 
    
    main()
